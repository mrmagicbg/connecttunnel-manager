#!/usr/bin/env python3
"""
ConnectTunnel Control Panel
============================

A persistent GUI window for managing ConnectTunnel with a taskbar presence.
This window stays on the taskbar (doesn't minimize to tray) and provides
easy access to connect/disconnect/exit functions.

Requires: PyQt5
Install: pip3 install PyQt5
"""

import sys
import os
import subprocess
import signal
import fcntl
from pathlib import Path
from typing import Optional
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QMessageBox, QStatusBar, QGroupBox, QTextEdit
)
from PyQt5.QtCore import QTimer, Qt
from PyQt5.QtGui import QIcon, QFont


class ConnectTunnelControlPanel(QMainWindow):
    """Main control panel window"""
    
    def __init__(self):
        super().__init__()
        
        self.tunnel_path = Path("/usr/local/Aventail")
        self.ui_script = self.tunnel_path / "startctui.sh"
        self.connect_script = self.tunnel_path / "startct.sh"
        self.process: Optional[subprocess.Popen] = None
        self.is_connected = False
        
        # Check if ConnectTunnel is installed
        if not self.ui_script.exists():
            QMessageBox.critical(
                self, "Error",
                f"ConnectTunnel not found at {self.tunnel_path}"
            )
            sys.exit(1)
        
        self.init_ui()
        
        # Timer to monitor connection status
        self.monitor_timer = QTimer()
        self.monitor_timer.timeout.connect(self.check_connection_status)
        self.monitor_timer.start(2000)  # Check every 2 seconds
        
        # Initial status check
        self.check_connection_status()
    
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("ConnectTunnel Control Panel")
        self.setMinimumSize(450, 400)
        
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QVBoxLayout()
        central_widget.setLayout(main_layout)
        
        # Title
        title_label = QLabel("ConnectTunnel Manager")
        title_font = QFont()
        title_font.setPointSize(16)
        title_font.setBold(True)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(title_label)
        
        # Status Group
        status_group = QGroupBox("Connection Status")
        status_layout = QVBoxLayout()
        status_group.setLayout(status_layout)
        
        self.status_label = QLabel("‚ö´ Disconnected")
        status_font = QFont()
        status_font.setPointSize(14)
        self.status_label.setFont(status_font)
        self.status_label.setAlignment(Qt.AlignCenter)
        status_layout.addWidget(self.status_label)
        
        main_layout.addWidget(status_group)
        
        # Control Buttons Group
        control_group = QGroupBox("Controls")
        control_layout = QVBoxLayout()
        control_group.setLayout(control_layout)
        
        # Connect button
        self.connect_btn = QPushButton("üîå Connect Tunnel")
        self.connect_btn.setMinimumHeight(50)
        button_font = QFont()
        button_font.setPointSize(12)
        self.connect_btn.setFont(button_font)
        self.connect_btn.clicked.connect(self.connect_tunnel)
        control_layout.addWidget(self.connect_btn)
        
        # Disconnect button
        self.disconnect_btn = QPushButton("üîå Disconnect")
        self.disconnect_btn.setMinimumHeight(50)
        self.disconnect_btn.setFont(button_font)
        self.disconnect_btn.clicked.connect(self.disconnect_tunnel)
        self.disconnect_btn.setEnabled(False)
        control_layout.addWidget(self.disconnect_btn)
        
        # Show Window button
        self.show_window_btn = QPushButton("ü™ü Show Tunnel Window")
        self.show_window_btn.setMinimumHeight(40)
        self.show_window_btn.clicked.connect(self.show_tunnel_window)
        self.show_window_btn.setEnabled(False)
        control_layout.addWidget(self.show_window_btn)
        
        main_layout.addWidget(control_group)
        
        # Info Group
        info_group = QGroupBox("Information")
        info_layout = QVBoxLayout()
        info_group.setLayout(info_layout)
        
        self.info_text = QTextEdit()
        self.info_text.setReadOnly(True)
        self.info_text.setMaximumHeight(80)
        self.info_text.setPlainText(
            "This control panel stays on your taskbar.\n"
            "Use the buttons above to manage your ConnectTunnel connection."
        )
        info_layout.addWidget(self.info_text)
        
        main_layout.addWidget(info_group)
        
        # Exit button (at bottom)
        exit_btn = QPushButton("‚ùå Exit Manager")
        exit_btn.setMinimumHeight(40)
        exit_btn.clicked.connect(self.exit_application)
        exit_btn.setObjectName("exit_btn")
        main_layout.addWidget(exit_btn)
        
        # Status bar
        self.statusBar().showMessage("Ready")
        
        # Apply stylesheet
        # Object names must be set BEFORE setStyleSheet so Qt can resolve selectors immediately
        self.disconnect_btn.setObjectName("disconnect_btn")
        self.show_window_btn.setObjectName("show_window_btn")
        self.apply_stylesheet()
    
    def apply_stylesheet(self):
        """Apply dark-only styling"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #121212;
            }
            QWidget {
                color: #f0f0f0;
                background-color: #121212;
            }
            QGroupBox {
                font-weight: bold;
                border: 1px solid #2a2a2a;
                border-radius: 8px;
                margin-top: 12px;
                padding-top: 12px;
                background-color: #1a1a1a;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 12px;
                padding: 0 6px;
                color: #cfcfcf;
            }
            QLabel {
                color: #e6e6e6;
            }
            QTextEdit {
                background-color: #1e1e1e;
                color: #e6e6e6;
                border: 1px solid #2a2a2a;
                border-radius: 6px;
            }
            QStatusBar {
                background-color: #1a1a1a;
                color: #e6e6e6;
                border-top: 1px solid #2a2a2a;
            }
            QPushButton {
                border: none;
                border-radius: 6px;
                padding: 12px;
                font-weight: bold;
                color: #ffffff;
                background-color: #2e7d32; /* default to green */
            }
            QPushButton:hover {
                background-color: #2f9e3a;
            }
            QPushButton:pressed {
                background-color: #267b32;
            }
            QPushButton:disabled {
                background-color: #2a2a2a;
                color: #777777;
            }
            QPushButton#disconnect_btn {
                background-color: #c62828;
            }
            QPushButton#disconnect_btn:hover {
                background-color: #e53935;
            }
            QPushButton#disconnect_btn:pressed {
                background-color: #b71c1c;
            }
            QPushButton#exit_btn {
                background-color: #616161;
            }
            QPushButton#exit_btn:hover {
                background-color: #757575;
            }
            QPushButton#exit_btn:pressed {
                background-color: #424242;
            }
            QPushButton#show_window_btn {
                background-color: #424242;
            }
            QPushButton#show_window_btn:hover {
                background-color: #4f4f4f;
            }
            QPushButton#show_window_btn:pressed {
                background-color: #3a3a3a;
            }
        """)

        # Note: object names are set in init_ui() before this call so Qt resolves
        # the #disconnect_btn / #show_window_btn selectors immediately.
    
    def find_tunnel_process(self) -> Optional[int]:
        """Find ConnectTunnel process ID"""
        try:
            result = subprocess.run(
                ["pgrep", "-f", "SnwlConnect.jar"],
                capture_output=True,
                text=True,
                timeout=2
            )
            if result.returncode == 0 and result.stdout.strip():
                return int(result.stdout.strip().split()[0])
        except Exception:
            pass
        return None
    
    def check_connection_status(self):
        """Check and update connection status"""
        pid = self.find_tunnel_process()
        was_connected = self.is_connected
        self.is_connected = pid is not None
        
        if self.is_connected:
            self.status_label.setText("üü¢ Connected")
            self.status_label.setStyleSheet("color: #4CAF50;")
            self.connect_btn.setEnabled(False)
            self.disconnect_btn.setEnabled(True)
            self.show_window_btn.setEnabled(True)
            self.statusBar().showMessage(f"Connected (PID: {pid})")
            
            if not was_connected:
                self.info_text.setPlainText(
                    f"‚úÖ Connected successfully!\n"
                    f"Process ID: {pid}\n"
                    f"Click 'Show Tunnel Window' to view the ConnectTunnel interface."
                )
        else:
            self.status_label.setText("‚ö´ Disconnected")
            self.status_label.setStyleSheet("color: #f44336;")
            self.connect_btn.setEnabled(True)
            self.disconnect_btn.setEnabled(False)
            self.show_window_btn.setEnabled(False)
            self.statusBar().showMessage("Disconnected")
            
            if was_connected:
                self.info_text.setPlainText(
                    "‚ùå Connection lost or disconnected.\n"
                    "Click 'Connect Tunnel' to reconnect."
                )
    
    def connect_tunnel(self):
        """Connect the tunnel"""
        # Double-check connection status before attempting to connect
        self.check_connection_status()
        
        if self.is_connected:
            QMessageBox.information(
                self, "Already Connected",
                "ConnectTunnel is already running.\n\n"
                "Use 'Show Tunnel Window' to bring it to the foreground."
            )
            return
        
        self.statusBar().showMessage("Starting ConnectTunnel...")
        self.info_text.setPlainText("üîÑ Starting ConnectTunnel...\nPlease wait...")
        
        # Disable connect button to prevent double-clicks
        self.connect_btn.setEnabled(False)
        
        try:
            self.process = subprocess.Popen(
                ["bash", str(self.ui_script)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                preexec_fn=os.setsid
            )
            
            # Wait a moment and check
            QTimer.singleShot(3000, self.verify_connection)
            
        except Exception as e:
            QMessageBox.critical(
                self, "Connection Error",
                f"Failed to start ConnectTunnel:\n{str(e)}"
            )
            self.info_text.setPlainText(f"‚ùå Error: {str(e)}")
            # Re-enable button on error
            self.connect_btn.setEnabled(True)
    
    def verify_connection(self):
        """Verify connection after starting ‚Äî updates info text, no intrusive modal."""
        if self.find_tunnel_process():
            self.info_text.setPlainText(
                "‚úÖ Connected successfully!\n"
                "The tunnel window should appear shortly.\n"
                "Click 'Show Tunnel Window' to bring it to the foreground."
            )
            self.statusBar().showMessage("Connected")
        else:
            QMessageBox.warning(
                self, "Connection Failed",
                "Failed to start ConnectTunnel.\n\n"
                "The process may have exited immediately."
            )
            self.info_text.setPlainText(
                "‚ùå Failed to start ConnectTunnel.\n"
                "Check that Java is installed and configured correctly."
            )
    
    def disconnect_tunnel(self):
        """Disconnect the tunnel"""
        # Force a fresh status check
        self.check_connection_status()
        
        if not self.is_connected:
            QMessageBox.information(
                self, "Not Connected",
                "ConnectTunnel is not running."
            )
            return
        
        reply = QMessageBox.question(
            self, "Confirm Disconnect",
            "Are you sure you want to disconnect the tunnel?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply != QMessageBox.Yes:
            return
        
        self.statusBar().showMessage("Disconnecting...")
        self.info_text.setPlainText("üîÑ Disconnecting ConnectTunnel...")
        
        # Disable disconnect button during operation
        self.disconnect_btn.setEnabled(False)
        
        try:
            # Direct process termination - skip startct.sh stop to avoid Java dialog
            self.info_text.append("‚Üí Sending SIGTERM to ConnectTunnel process...")
            
            # First, try graceful SIGTERM
            subprocess.run(
                ["pkill", "-TERM", "-f", "SnwlConnect.jar"],
                timeout=2,
                capture_output=True
            )
            
            # Schedule post-SIGTERM check without blocking the event loop
            self.info_text.append("‚Üí Waiting for graceful shutdown...")
            QTimer.singleShot(1000, self._check_after_sigterm)
            
        except Exception as e:
            QMessageBox.warning(
                self, "Disconnect Error",
                f"Error sending SIGTERM:\n{str(e)}\n\n"
                "The tunnel may still be running."
            )
            self.info_text.setPlainText(f"‚ö†Ô∏è Disconnect error: {str(e)}")
            self.disconnect_btn.setEnabled(True)
            QTimer.singleShot(500, self.check_connection_status)

    def _check_after_sigterm(self):
        """Second disconnect phase: check state after SIGTERM grace period."""
        check_result = subprocess.run(
            ["pgrep", "-f", "SnwlConnect.jar"],
            capture_output=True
        )
        if check_result.returncode == 0:
            self.info_text.append("‚Üí Process still running, forcing SIGKILL...")
            subprocess.run(["pkill", "-9", "-f", "SnwlConnect.jar"], timeout=2, capture_output=True)
            subprocess.run(["pkill", "-9", "-f", "startctui.sh"], timeout=2, capture_output=True)
            QTimer.singleShot(1000, self._finalize_disconnect)
        else:
            self.info_text.append("‚Üí Process stopped gracefully")
            self._finalize_disconnect()

    def _finalize_disconnect(self):
        """Final disconnect phase: verify and report result."""
        final_check = subprocess.run(
            ["pgrep", "-f", "SnwlConnect.jar"],
            capture_output=True
        )
        if final_check.returncode == 0:
            QMessageBox.warning(
                self, "Disconnect Warning",
                "ConnectTunnel process may still be running.\n"
                "You may need to disconnect manually using:\n"
                "sudo pkill -9 -f SnwlConnect"
            )
            self.info_text.setPlainText("‚ö†Ô∏è Disconnection incomplete - process may still be running")
        else:
            QMessageBox.information(self, "Disconnected", "ConnectTunnel has been disconnected.")
            self.info_text.setPlainText("‚úÖ Disconnected successfully.")
        
        self.disconnect_btn.setEnabled(True)
        QTimer.singleShot(500, self.check_connection_status)
    
    def show_tunnel_window(self):
        """Bring tunnel window to front"""
        try:
            # Try wmctrl
            result = subprocess.run(
                ["wmctrl", "-a", "SnwlConnect"],
                timeout=2,
                capture_output=True
            )
            
            if result.returncode != 0:
                # Try xdotool
                subprocess.run(
                    ["xdotool", "search", "--name", "SnwlConnect", "windowactivate"],
                    timeout=2,
                    capture_output=True
                )
            
            self.statusBar().showMessage("Brought tunnel window to front")
            
        except Exception as e:
            QMessageBox.information(
                self, "Window Not Found",
                "Could not find the ConnectTunnel window.\n\n"
                "Try using Alt+Tab to find it manually."
            )
    
    def exit_application(self):
        """Exit the application"""
        if self.is_connected:
            reply = QMessageBox.question(
                self, "Exit Manager",
                "ConnectTunnel is still connected.\n\n"
                "Do you want to disconnect before exiting?",
                QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel,
                QMessageBox.Cancel
            )
            
            if reply == QMessageBox.Cancel:
                return
            
            if reply == QMessageBox.Yes:
                self.disconnect_tunnel()
        
        self.close()
    
    def closeEvent(self, event):
        """Handle window close event"""
        if self.is_connected:
            reply = QMessageBox.question(
                self, "Close Window",
                "ConnectTunnel is still running.\n\n"
                "Close this control panel anyway?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply == QMessageBox.No:
                event.ignore()
                return
        
        event.accept()


def main():
    """Main entry point"""
    # Single instance lock
    lock_file = Path("/tmp/connecttunnel-control-panel.lock")
    lock_fd = None
    
    try:
        lock_fd = open(lock_file, 'w')
        fcntl.flock(lock_fd.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        # Another instance is running
        app = QApplication(sys.argv)
        QMessageBox.warning(
            None,
            "Already Running",
            "ConnectTunnel Control Panel is already running.\n\n"
            "Please check your taskbar or system tray."
        )
        sys.exit(1)
    
    app = QApplication(sys.argv)
    app.setApplicationName("ConnectTunnel Control Panel")
    
    # Create and show window
    window = ConnectTunnelControlPanel()
    window.show()
    
    exit_code = app.exec()
    
    # Release lock
    if lock_fd:
        fcntl.flock(lock_fd.fileno(), fcntl.LOCK_UN)
        lock_fd.close()
        try:
            lock_file.unlink()
        except OSError as e:
            print(f"Warning: could not remove lock file {lock_file}: {e}", file=sys.stderr)
    
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
